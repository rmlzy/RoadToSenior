## 二叉树

[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)的定义：

在计算机科学中，二叉树（Binary Tree）是每个节点最多只有两个分支的树结构。通常分支被称为 “左子树” 或 “右子树”。二叉树的分支具有左右次序，不能随意颠倒。

下图是一个有 9 个节点且深度为 3 的二叉树：

![image-20210225165900304](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225165900304.png)

二叉树的几个特点：

1. 二叉树的第 i 层最多有 2^(i - 1) 个节点；
2. 深度为 k 的二叉树最多有 2^k - 1 个节点；

计算机科学中有很多树：

![image-20210225170519409](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170519409.png)

## 二叉查找树

二叉查找树（Binary Search Tree）是一种特殊的二叉树，相对较小的值保存在左节点，较大的值保存在右节点，这一特性使得查找的效率很高。

下图是一个有 7 个节点且深度为 4 的搜索二叉树：

![image-20210225165916750](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225165916750.png)

通过以下示例代码梳理一下 BST 的生成步骤，后边会用 JS 实现 BST：

```javascript
const nums = new BST();
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(100);
```

第一步：插入节点 23，此时 BST 为：

![image-20210225165953551](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225165953551.png)

第二步：插入节点 45, 45 大于 23，放在 23 右边，此时 BST 为：

![image-20210225170017487](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170017487.png)

第三步：插入节点 16，16 小于 23，放在 23 左边，此时 BST 为：

![image-20210225170040570](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170040570.png)

第四步：插入节点 37，37 大于 23，放在 23 的右边，同时 37 小于 45，放在 45 的左边，此时 BST 为：

![image-20210225170111638](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170111638.png)

第五步：插入节点 3，3 小于 23，放在 23 的左边，同时 3 小于 16，放在 16 的左边，此时 BST 为：

![image-20210225171035165](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171035165.png)

第六步：插入节点 99，99 大于 23，放在 23 的右边，同时 99 大于 45，放在 45 的右边，此时 BST 为：

![image-20210225171738183](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171738183.png)

第七步：插入节点 100，100 大于 23，放在 23 的右边，同时 100 大于 45 放在 45 的右边，同时 100 大于 99，放在 99 的右边，此时 BST 为：

![image-20210225171849141](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171849141.png)



二叉查找树有三种遍历方式，前序、中序和后序。

+ 深度优先遍历：从根节点到访问最远的节点。
  + 前序遍历：根节点 -> 左子树 -> 右子树。
  + 中序遍历：左子树 -> 根节点 -> 右子树。（升序遍历所有节点）
  + 后序遍历：左子树 -> 右子树 -> 根节点。
+ 广度优先遍历：和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。

以上边生成的 BST 为例：

![image-20210225171035165](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171849141.png)

前序遍历时：23 -> 16 -> 3 -> 45 -> 37 -> 99 -> 100

中序遍历时：3 -> 16 -> 23 -> 37 -> 45 -> 99 -> 100

后序遍历时：3 -> 16 -> 100 -> 37 -> 99 -> 45 -> 23

## JS 实现二叉树

```javascript
class Node {
  constructor(data, left, right) {
    this.data = data;
    this.left = left;
    this.right = right;
  }

  show() {
    return this.data;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  insert(data) {
    const n = new Node(data, null, null);
    if (this.root === null) {
      this.root = n;
    } else {
      let current = this.root;
      let parent;
      while (true) {
        parent = current;
        if (data < current.data) {
          current = current.left;
          if (current === null) {
            parent.left = n;
            break;
          }
        } else {
          current = current.right;
          if (current === null) {
            parent.right = n;
            break;
          }
        }
      }
    }
  }

  preOrder(node) {
    if (node !== null) {
      console.log(node.show());
      this.preOrder(node.left);
      this.preOrder(node.right);
    }
  }

  inOrder(node) {
    if (node !== null) {
      this.inOrder(node.left);
      console.log(node.show());
      this.inOrder(node.right);
    }
  }

  postOrder(node) {
    if (node !== null) {
      this.postOrder(node.left);
      this.postOrder(node.right);
      console.log(node.show());
    }
  }

  getMin() {
    let current = this.root;
    while (!(current.left == null)) {
      current = current.left;
    }
    return current.data;
  }

  getMax() {
    let current = this.root;
    while (!(current.right == null)) {
      current = current.right;
    }
    return current.data;
  }
}
```

测试中序遍历：

```javascript
const nums = new BST();
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(100);
nums.preOrder(nums.root); // 输出：23 16 3 45 37 99 100
nums.inOrder(nums.root); // 输出：3 16 23 37 45 99 100
nums.postOrder(nums.root); // 输出：3 16 37 100 99 45 23
console.log(nums.getMin()); // 输出：3
console.log(nums.getMax()); // 输出：100
```

## 使用二叉树

### 算法题：给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

来源：力扣（LeetCode）
```

### 算法题：电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://poppython.oss-cn-beijing.aliyuncs.com/blog/17_telephone_keypad.png)

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

