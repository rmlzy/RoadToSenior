## 二叉树

[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)的定义：

在计算机科学中，二叉树（Binary Tree）是每个节点最多只有两个分支的树结构。通常分支被称为 “左子树” 或 “右子树”。二叉树的分支具有左右次序，不能随意颠倒。

下图是一个有 9 个节点且深度为 3 的二叉树：

![image-20210225165900304](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225165900304.png)

二叉树的几个特点：

1. 二叉树的第 i 层最多有 2^(i - 1) 个节点；
2. 深度为 k 的二叉树最多有 2^k - 1 个节点；

计算机科学中有很多树：

![image-20210225170519409](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170519409.png)

## 二叉查找树

二叉查找树（Binary Search Tree）是一种特殊的二叉树，相对较小的值保存在左节点，较大的值保存在右节点，这一特性使得查找的效率很高。

下图是一个有 7 个节点且深度为 4 的搜索二叉树：

![image-20210225165916750](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225165916750.png)

通过以下示例代码梳理一下 BST 的生成步骤，后边会用 JS 实现 BST：

```javascript
const nums = new BST();
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(100);
```

第一步：插入节点 23，此时 BST 为：

![image-20210225165953551](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225165953551.png)

第二步：插入节点 45, 45 大于 23，放在 23 右边，此时 BST 为：

![image-20210225170017487](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170017487.png)

第三步：插入节点 16，16 小于 23，放在 23 左边，此时 BST 为：

![image-20210225170040570](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170040570.png)

第四步：插入节点 37，37 大于 23，放在 23 的右边，同时 37 小于 45，放在 45 的左边，此时 BST 为：

![image-20210225170111638](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225170111638.png)

第五步：插入节点 3，3 小于 23，放在 23 的左边，同时 3 小于 16，放在 16 的左边，此时 BST 为：

![image-20210225171035165](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171035165.png)

第六步：插入节点 99，99 大于 23，放在 23 的右边，同时 99 大于 45，放在 45 的右边，此时 BST 为：

![image-20210225171738183](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171738183.png)

第七步：插入节点 100，100 大于 23，放在 23 的右边，同时 100 大于 45 放在 45 的右边，同时 100 大于 99，放在 99 的右边，此时 BST 为：

![image-20210225171849141](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171849141.png)



二叉查找树有三种遍历方式，前序、中序和后序。

+ 深度优先遍历：从根节点到访问最远的节点。
  + 前序遍历：根节点 -> 左子树 -> 右子树。
  + 中序遍历：左子树 -> 根节点 -> 右子树。（升序遍历所有节点）
  + 后序遍历：左子树 -> 右子树 -> 根节点。
+ 广度优先遍历：和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。

以上边生成的 BST 为例：

![image-20210225171035165](https://poppython.oss-cn-beijing.aliyuncs.com/blog/image-20210225171849141.png)

前序遍历时：23 -> 16 -> 3 -> 45 -> 37 -> 99 -> 100

中序遍历时：3 -> 16 -> 23 -> 37 -> 45 -> 99 -> 100

后序遍历时：3 -> 16 -> 100 -> 37 -> 99 -> 45 -> 23

## JS 实现二叉树

```javascript
class Node {
  constructor(data, left, right) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
  
  show() {
    return this.data;
  }
}

class BST {
  constructor {
    this.root = null;
  }

	insert(data) {
    const n = new Node(data, null, null);
    if (this.root === null) {
      this.root = n;
    } else {
      let current = this.root;
      let parent;
      while (true) {
        parent = current;
        if (data < current.data) {
          current = current.left;
          if (current === null) {
            parent.left = n;
            break;
          }
        } else {
          current = current.right;
          if (current === null) {
            parent.right = n;
            break;
          }
        }
      }
    }
  }

	preOrder(node) {
  	if (node !== null) {
    	console.log(node.show());
    	this.preOrder(node.left);
    	this.preOrder(node.right);
  	}
	}

	inOrder(node) {
  	if (node !== null) {
    	this.inOrder(node.left);
    	console.log(node.show());
    	this.inOrder(node.right);
  	}
	}

	postOrder(node) {
  	if (node !== null) {
    	this.postOrder(node.left);
    	this.postOrder(node.right);
    	console.log(node.show());
  	}
	}
}
```

测试中序遍历：

```javascript
const nums = new BST();
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(100);
nums.preOrder(nums.root); // 输出：23 16 3 45 37 99 100
nums.inOrder(nums.root); // 输出：3 16 23 37 45 99 100
nums.postOrder(nums.root); // 输出：3 16 37 100 99 45 23
```



## 使用二叉树

